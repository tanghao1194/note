---
title: 2018-10-11学习笔记 
一、***==array对象==***
1.a.slice(x,y); 
  a:一个数组 ； x：起始位置（从0开始）；y：终止位置（该位置元素本身不包括在内）；
2. splice（）    splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
  2.1  arr.splice(start, count, addElement1, addElement2, ...);
        splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
		var a = ['a', 'b', 'c', 'd', 'e', 'f'];
             a.splice(4, 2) // ["e", "f"]
             a // ["a", "b", "c", "d"]
			 
        var a = ['a', 'b', 'c', 'd', 'e', 'f'];
              a.splice(4, 2, 1, 2) // ["e", "f"]
              a // ["a", "b", "c", "d", 1, 2]
			  
			  var a = ['a', 'b', 'c', 'd', 'e', 'f'];
                    a.splice(-4, 2) // ["c", "d"]
					
var a = [1, 2, 3, 4];
a.splice(2) // [3, 4]
a // [1, 2]

3.sort（）  按照字典顺序排序
 3.1 可以传入函数function作为参数  自定义排序方法
      [10111, 1101, 111].sort(function (a, b) {
                                                                        return a - b;
                                                                 })             // [111, 1101, 10111]
 4. map（） map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。
 var numbers = [1, 2, 3];
numbers.map(function (n) {
  return n + 1;
});
// [2, 3, 4]

numbers
// [1, 2, 3]
5. forEach（）  forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。
 function log(element, index, array) {
  console.log('[' + index + '] = ' + element);
}

[2, 5, 9].forEach(log);
// [0] = 2
// [1] = 5
// [2] = 9
6.filter（） filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。
                它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
				[1, 2, 3, 4, 5].filter(function (elem) {
                                    return (elem > 3);
                                     })
                                   // [4, 5]
7.some（） every（）  这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。

它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。

some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 var arr = [1, 2, 3, 4, 5];
arr.some(function (elem, index, arr) {
  return elem >= 3;
});
// true

every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。var arr = [1, 2, 3, 4, 5];
arr.every(function (elem, index, arr) {
  return elem >= 3;
});
// false
8.ruduce（） ruduceRight（）  reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。
    [1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
                          [1, 2, 3, 4, 5].reduce(function (a, b) {
                           return a + b;
                           }, 10);
                           // 25
9.indexOf（） LastIndexOf（）
    indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。
	var a = ['a', 'b', 'c'];
a.indexOf('b') // 1
a.indexOf('y') // -1
indexOf方法还可以接受第二个参数，表示搜索的开始位置。
['a', 'b', 'c'].indexOf('a', 1) // -1

lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
  var a = [2, 5, 9, 2];
a.lastIndexOf(2) // 3
a.lastIndexOf(7) // -1
**==二、包装对象==**
2.1 包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。
     Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。
	 总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。
2.2 valueOf（）valueOf方法返回包装对象实例对应的原始类型的值。
   new Number(123).valueOf()  // 123
new String('abc').valueOf() // "abc"
new Boolean(true).valueOf() // true
2.3 toString（） toString方法返回对应的字符串形式。
  new Number(123).toString() // "123"
new String('abc').toString() // "abc"
new Boolean(true).toString() // "true" 
2.3 **Boolean对象**
   Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。
   Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean('') // false
Boolean(NaN) // false

Boolean(1) // true
Boolean('false') // true
Boolean([]) // true
Boolean({}) // true
Boolean(function () {}) // true
Boolean(/foo/) // true
    顺便提一下，使用双重的否运算符（!）也可以将任意值转为对应的布尔值。
	 !!undefined // false
!!null // false
!!0 // false
!!'' // false
!!NaN // false

!!1 // true
!!'false' // true
!![] // true
!!{} // true
!!function(){} // true
!!/foo/ // true
==三,Number对象==
3.1  toFixed      toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。
      (10).toFixed(2) // "10.00"
10.005.toFixed(2) // "10.01"
3.2  toExponential()    用于将一个数转为科学计数法形式。
(10).toExponential()  // "1e+1"
(10).toExponential(1) // "1.0e+1"
(10).toExponential(2) // "1.00e+1"

(1234).toExponential()  // "1.234e+3"
(1234).toExponential(1) // "1.2e+3"
(1234).toExponential(2) // "1.23e+3"
3.3 toPrecision()   用于将一个数转为指定位数的有效数字。
(12.34).toPrecision(1) // "1e+1"
(12.34).toPrecision(2) // "12"
(12.34).toPrecision(3) // "12.3"
(12.34).toPrecision(4) // "12.34"
(12.34).toPrecision(5) // "12.340"  

==四，String对象==
4.1 String.fromCharCode()  该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。
   String.fromCharCode() // ""
String.fromCharCode(97) // "a"
String.fromCharCode(104, 101, 108, 108, 111)
// "hello"   
4.2   String.prototype.charAt()   charAt方法返回指定位置的字符，参数是从0开始编号的位置。   
  var s = new String('abc');

s.charAt(1) // "b"
s.charAt(s.length - 1) // "c"
4.3 String.prototype.charCodeAt()    charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。
'abc'.charCodeAt(1) // 98   
4.4 String.prototype.concat()  concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。
var s1 = 'abc';
var s2 = 'def';

s1.concat(s2) // "abcdef"
s1 // "abc"
4.5 String.prototype.slice()  slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。
**==五、Math对象==**
5.1 